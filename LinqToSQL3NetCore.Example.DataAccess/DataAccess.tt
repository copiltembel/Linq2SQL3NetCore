<# // L2ST4 - LINQ to SQL templates for T4 v0.86 - http://www.codeplex.com/l2st4
// Copyright (c) Microsoft Corporation.  All rights reserved.
// This source code is made available under the terms of the Microsoft Public License (MS-PL)
#><#@ template language="C#" hostspecific="True" debug="true"
#><#@ include file="T4utils.ttinclude"
#><#@ output extension=".cs"
#><# // Set options here
var options = new {
	DbmlFileName = Host.TemplateFile.Replace(".tt",".dbml"), // Which DBML file to operate on (same filename as template)
	SerializeDataContractSP1 = true, // Emit SP1 DataContract serializer attributes
	FilePerEntity = false, // Put each class into a separate file
	StoredProcedureConcurrency = false, // Table updates via an SP require @@rowcount to be returned to enable concurrency
	DbEntityBaseClassName = "DbEntity"
}; 

// we have the option to move all tables into separate files (to avoid this gigantic file), to do so, simply set this boolean to true and follow the following instructions:
// https://damieng.com/blog/2009/01/22/multiple-outputs-from-t4-made-easy
const bool ADD_TABLE_NAMESPACE = false;

var code = new CSharpCodeLanguage();
var data = new Data(options.DbmlFileName);
var manager = Manager.Create(Host, GenerationEnvironment); 
data.ContextNamespace = (new string[] { manager.GetCustomToolNamespace(data.DbmlFileName), data.SpecifiedContextNamespace, manager.DefaultProjectNamespace }).FirstOrDefault(s => !String.IsNullOrEmpty(s));
data.EntityNamespace = (new string[] { manager.GetCustomToolNamespace(data.DbmlFileName), data.SpecifiedEntityNamespace, manager.DefaultProjectNamespace }).FirstOrDefault(s => !String.IsNullOrEmpty(s));
manager.StartHeader();
#>#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated> 
//     This code was generated by LINQ to SQL template for T4 C#
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<# manager.EndBlock();
if(!String.IsNullOrEmpty(data.ContextNamespace)){#>
namespace <#=data.ContextNamespace#>
{
<#}#>
    using System;
    using System.ComponentModel;
    using System.Data.Linq;
    using System.Data.Linq.Mapping;
	using LinqToSQL3.Example.DataAccess;
    <#if (data.Functions.Count > 0) {#>
using System.Reflection;
    <#}
    string dataContractAttributes = (options.SerializeDataContractSP1) ? "IsReference=true" : "";
    if (data.Serialization) {#>
    using System.Runtime.Serialization;
    <#}#>

   //Warning: Avoid using an existing table name for the database name
	[global::System.Data.Linq.Mapping.DatabaseAttribute(Name=@"<#=data.DatabaseName#>")]
	<#=code.Format(data.TypeAttributes)#>partial class <#=data.ContextName#> : System.Data.Linq.<#=AddFullNamespace(data.BaseClassName)#>
	{
		private static MappingSource mappingSource = new AttributeMappingSource();
		
		#region Extensibility Method Definitions

		partial void OnCreated();
<#	var tableOperations = new List<TableOperation>();
	foreach(var table in data.Tables)
    {
        tableOperations.AddRange(table.Operations);
    }

	foreach(var table in data.Tables.Where(t => !IgnoreTable(t.BaseClass.Name)))
		foreach(OperationType operationType in Enum.GetValues(typeof(OperationType)))
			if (!tableOperations.Any(o => (o.Table == table) && (o.Type == operationType))) {#>
		partial void <#=operationType#><#=table.BaseClass.Name#>(<#=table.BaseClass.QualifiedName#> instance);
<#}#>
		#endregion
		
		#region Construction
<#if (data.ConnectSettingsObject != null) {#>
		public <#=data.ContextName#>() :
			base(global::<#=data.ConnectSettingsObject#>.Default.<#=data.ConnectSettingsProperty#>, mappingSource)
		{
			OnCreated();
		}
<#}#>	
		public <#=data.ContextName#>(string connection) :
			base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public <#=data.ContextName#>(System.Data.IDbConnection connection) :
			base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public <#=data.ContextName#>(string connection, MappingSource mappingSource) :
			base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public <#=data.ContextName#>(System.Data.IDbConnection connection, MappingSource mappingSource) :
			base(connection, mappingSource)
		{
			OnCreated();
		}
		#endregion
<#if(data.Tables.Count > 0) {#>
		
		#region Tables
<#	foreach(var table in data.Tables.Where(t => !IgnoreTable(t.BaseClass.QualifiedName))) {
#>		<#=code.GetAccess(table.TypeAttributes)#>System.Data.Linq.Table<<#=table.BaseClass.QualifiedName#>> <#=table.Member#>
		{
			get 
            { 
                return this.GetTable<<#=table.BaseClass.QualifiedName#>>(); 
            }
		}
		
<#	}
#>		#endregion
<#}
if (data.Functions.Count > 0) {#>
		
		#region Functions
<#	foreach(var function in data.Functions.Where(f => !IgnoreTable(f.Name))) {
#>
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="<#=function.Name#>"<#
		if (function.IsComposable) {#>, IsComposable=true<#}
		#>)]
<#		if (function.Return != null && function.Return.DbType != null) {
#>		[return: global::System.Data.Linq.Mapping.ParameterAttribute(DbType=@"<#=function.Return.DbType#>")]
<#		}
		if (function.HasMultipleResults) {
                foreach(var class1 in function.Classes) {#>
		[ResultType(typeof(<#=class1.QualifiedName#>))]
<#			}
		}#>
		<#=code.Format(function.MemberAttributes)#><#=code.Format(function.ReturnType)#> <#=function.Method#>(<#
		foreach(var parameter in function.Parameters) {#>

				[Parameter(<#if (parameter.DbName != parameter.Name) {#>Name=@"<#=parameter.DbName#>", <#}#>DbType=@"<#=parameter.DbType#>")] <#=code.Format(parameter.Direction)#><#=code.Format(parameter.Type)#> <#=parameter.Name#><#
			if (parameter != function.Parameters.Last()) {#>,<# }
		}
		#>) {
<#		foreach(var outParameter in function.Parameters.Where(p => p.Direction == ParameterDirection.Out)) {#>
			<#=outParameter.Name#> = default(<#=code.Format(outParameter.Type)#>);
<#		}
		if (function.IsComposableQuery) { #>
			return CreateMethodCallQuery<<#=code.Format(function.ResultType)#>>(this, ((MethodInfo)(MethodInfo.GetCurrentMethod()))<#=String.Join("", function.Parameters.Select(p => ", " + p.Name).ToArray())#>);
<#		} else { #>
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod()))<#=String.Join("", function.Parameters.Select(p => ", " + p.Name).ToArray())#>);
<#			int paramIdx = 0;
			foreach(var parameter in function.Parameters) {
				if (parameter.Direction != ParameterDirection.In) {#>
			<#=parameter.Name#> = (<#=code.Format(parameter.Type)#>) result.GetParameterValue(<#=paramIdx#>);
<#				}
				paramIdx++;
			}
#>			return ((<#=code.Format(function.ReturnType)#>)(result.ReturnValue));
<#		}#>
		}
		
<#	}#>
		#endregion
		
<#	if (tableOperations.Count > 0) { #>
		#region Table Operations 
<#		foreach(var operation in tableOperations) { #>
		private void <#=operation.Type#><#=operation.Table.BaseClass.Name#>(<#=operation.Table.BaseClass.QualifiedName#> obj) {
<#			if (operation.Arguments.Any(a => a.Version == ArgumentVersion.Original)) {
#>			var original = <#=operation.Table.Member#>.GetOriginalEntityState(obj);
<#			}
			int paramIdx = 1;
			foreach(var argument in operation.Arguments.Where(a => a.Parameter.Direction != ParameterDirection.In)) {
#>			<#=code.Format(argument.Parameter.Type)#> p<#=paramIdx++#> = obj.<#=argument.Member#>;
<#			}#>
			<# if (options.StoredProcedureConcurrency) {#>var rowCount = <#}#><#=operation.Function.Method#>(<#
			paramIdx = 1;
			foreach(var argument in operation.Arguments) {
				switch(argument.Parameter.Direction) {
					case ParameterDirection.InOut: #>ref p<#=paramIdx++#><# break;
					case ParameterDirection.Out: #>out p<#=paramIdx++#><# break;
					default: #><#=(argument.Version == ArgumentVersion.New) ? "obj" : "original"#>.<#=argument.Member#><# break;
				}
			if (argument != operation.Arguments.Last()) {#>, <#}
			}
			#>);
<#			if (options.StoredProcedureConcurrency) {#>
			if (rowCount != 1) {
				throw new ChangeConflictException();
			}
<#			}
			paramIdx = 1;
			foreach(var argument in operation.Arguments.Where(a => a.Parameter.Direction != ParameterDirection.In)) {
#>			obj.<#=argument.Member#> = p<#=paramIdx++#>.GetValueOrDefault();
<#			}#>
		}
		
<#
		}
#>
		#endregion
<#	}
}
// ======================================================
// Table generation
// ======================================================
#>
	}

    #region Start table generation
<#
foreach(var table in data.Tables)
{      
    // we only need namespaces for each table if we decide to move tables into separate files)
if (ADD_TABLE_NAMESPACE && !String.IsNullOrEmpty(data.EntityNamespace)) {
#>
    namespace <#=AddFullNamespace(data.EntityNamespace)#>
    {<#   }

	foreach(var class1 in table.Classes.Where(c => !IgnoreTable(c.Name))) 
    {
		manager.StartNewFile(Path.ChangeExtension(class1.Name,".generated.cs"));

		if (data.Serialization && class1.IsSerializable) {
    #>[DataContract(<#=dataContractAttributes#>)]
<#		}
		if (class1 == table.BaseClass) {#>
        
    [Table(Name=@"<#=table.Name#>")]<#
			foreach(var subclass in data.TableClasses.Where(c => c.Table == table)) {
				if (!String.IsNullOrEmpty(subclass.InheritanceCode)) {#>
	[InheritanceMapping(Code=@"<#=subclass.InheritanceCode#>", Type=typeof(<#=subclass.Name#>)<# if (subclass.IsInheritanceDefault) {#>, IsDefault=true<#}#>)]
<#				}
				if (data.Serialization && subclass.IsSerializable) {
#>	[KnownType(typeof(<#=subclass.Name#>))]<#}
			}#>  
    <#=code.Format(class1.TypeAttributes)#>partial class <#=class1.Name#> : <#=options.DbEntityBaseClassName#><<#=class1.Name#>,<#=class1.Columns.Single(c => c.IsPrimaryKey).StorageType#>><#= GetInterfaces(class1.Columns, class1.Name) #>
	{
<#		} else {
#>	<#=code.Format(class1.TypeAttributes)#>partial class <#=class1.Name#> : <#=class1.SuperClass.Name#>
	{
<#		}#>

        <# 
        foreach(var column in class1.Columns) 
        {
        #>private <#if (column.IsPrimaryKey || column.ForeignKeyAssociations.Any()) {#> <#=column.GetStorageTypeDbId#> <#} else {#> <#=CleanMemberType(code.Format(column.StorageType))#> <#}#> <#=column.Storage#><# if (column.IsReadOnly) {#> = default(<#=code.Format(column.StorageType)#>)<#}#>;
        
        <#}

		#>#region Extensibility Method Definitions
		partial void OnLoaded();
		partial void OnValidate(System.Data.Linq.ChangeAction action);
<#		if (class1.HasPrimaryKey) {#>
		partial void OnCreated();
<#		}#>
 <#		foreach(var column in class1.Columns) 
        {
		#>
        partial void On<#=column.Member#>Changing(<#if (column.IsPrimaryKey || column.ForeignKeyAssociations.Any()) {#> <#=column.GetStorageTypeDbId#> <#}#><#else {#> <#=CleanMemberType(code.Format(column.Type))#> <#}#> value);
		partial void On<#=column.Member#>Changed();
        <#}#>
		#endregion

		#region Construction
		public <#=class1.Name#>()
		{
<#		if (data.Serialization) {
#>			Initialize();
		}
		
		private void Initialize()
		{
<#		}
		foreach(var association in class1.Associations) {
#>			this.<#=association.Storage#> = <#
			if (association.IsMany) {
				#>new EntitySet<<#=association.Type.Name#>>(attach_<#=association.Member#>, detach_<#=association.Member#>);
<#			} else {
				#>default(EntityRef<<#=association.Type.Name#>>); 
<#			}
		}
		if (class1.HasPrimaryKey) {#>
			OnCreated();
<#		}#>
		}
		#endregion

<#		int dataMemberIndex = 1;
		if (class1.Columns.Count > 0) 
        {
#>		#region Column Mappings
<#		foreach(var column in class1.Columns) 
        {
		#>
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="<#=column.Storage#>"<#
		if (column.Name != column.Member) {#>, Name="<#=column.Name#>"<#}
		if (column.AutoSync != AutoSync.Default) {#>, AutoSync=AutoSync.<#=column.AutoSync.ToString()#><#}
		if (!String.IsNullOrEmpty(column.DbType)) {#>, DbType="<#=column.DbType#>"<#}
		if (column.IsPrimaryKey) {#>, IsPrimaryKey=true<#}
		if (column.IsDiscriminator) {#>, IsDiscriminator=true<#}
		if (column.IsDbGenerated) {#>, IsDbGenerated=true<#}
		if (column.IsVersion) {#>, IsVersion=true<#}
		if (!column.CanBeNull && !column.IsPrimaryKey) {#>, CanBeNull=false<#}
		if (column.UpdateCheck != UpdateCheck.Always) {#>, UpdateCheck=UpdateCheck.<#=column.UpdateCheck.ToString()#><#}
		if (!String.IsNullOrEmpty(column.Expression)) {#>, Expression="<#=column.Expression#>"<#}
	    #>)]
<#

    	if (data.Serialization && ((column.MemberAttributes & MemberAttributes.AccessMask) == MemberAttributes.Public)) {
#>		[DataMember(Order=<#=dataMemberIndex++#>)]
<#		}
#>
        <#=code.Format(column.MemberAttributes)#> <#if ((column.IsPrimaryKey || column.ForeignKeyAssociations.Any())) {#> <#=column.GetStorageTypeDbId#> <#}#><#else {#> <#=CleanMemberType(code.Format(column.Type))#> <#}#> <#=column.Member#>
		{
			get 
            { 
                return this.<#=column.StorageValue#>; 
            }
<#			if (!column.IsReadOnly) { #>
			set 
            {
				if ((this.<#=column.StorageValue#> != value)) 
                {
<#					if (column.ForeignKeyAssociations.Count > 0) {#>
					if (this.<#=String.Join(" || ", column.ForeignKeyAssociations.Select(a => a.Storage + ".HasLoadedOrAssignedValue").ToArray())#>) 
                    {
						throw new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException();
					}
<#					}#>
					this.On<#=column.Member#>Changing(value);
					this.SendPropertyChanging();
					this.<#=column.StorageValue#> = value;
					this.SendPropertyChanged("<#=column.Member#>");
					this.On<#=column.Member#>Changed();
				}
			}
<#          } // end column is readonly#>
		}
		
<#  }#>
		#endregion
<#	}
		bool needsSerializationFlag = class1.IsSerializable && class1.Associations.Any(a => !a.ManagesKeys);
		if (class1.Associations.Count > 0) {
#>		
		#region Associations
<#			foreach(var association in class1.Associations) {#>
		private Entity<#=(association.IsMany) ? "Set" : "Ref"#><<#=association.Type.Name#>> <#=association.Storage#>;
		[global::System.Data.Linq.Mapping.AssociationAttribute(Name="<#=association.Name#>"<#
			#>, Storage="<#=association.Storage#>"<#
				if (association.ThisKeyMembers != null) {#>, ThisKey="<#=String.Join(",", association.ThisKeyMembers)#>"<#}
				if (association.OtherKeyMembers != null) {#>, OtherKey="<#=String.Join(",", association.OtherKeyMembers)#>"<#}
				if (association.IsForeignKey) {#>, IsForeignKey=true<#}
				if (association.IsUnique) {#>, IsUnique=true, IsForeignKey=false<#}
				if (association.DeleteOnNull) {#>, DeleteOnNull=true<#}
				if (association.DeleteRule != null) {#>, DeleteRule="<#=association.DeleteRule #>"<#}
		#>)]
<#				bool serialization = association.IsSerializable && data.Serialization &&
					(options.SerializeDataContractSP1 || !association.ManagesKeys);
				if (serialization) {
#>		[DataMember(Order=<#=dataMemberIndex++#>, EmitDefaultValue=false)]
<#				}
				if (!association.IsMany) {#>
		<#=code.Format(association.MemberAttributes)#><#=association.Type.Name#> <#=association.Member#>
		{
			get 
            {
<#					if (needsSerializationFlag && serialization) {#>
				if (serializing && !<#=association.Storage#>.HasLoadedOrAssignedValue) {
					return null;
				}
<#					}#>
				return this.<#=association.Storage#>.Entity;
			}
			set 
            {
				<#=association.Type.Name#> previousValue = this.<#=association.Storage#>.Entity;
				if (((previousValue != value)<#if (association.OtherSide != null) {#> 
                            || (this.<#=association.Storage#>.HasLoadedOrAssignedValue == false)<#}#>)) 
                {
					this.SendPropertyChanging();
<#					if (association.OtherSide != null) {#>
					if ((previousValue != null)) 
                    {
						this.<#=association.Storage#>.Entity = null;
						previousValue.<#=association.OtherSide.Member#><#if (!association.OtherSide.IsMany) {#> = null<#} else {#>.Remove(this)<#}#>;
					}
<#					}
#>					this.<#=association.Storage#>.Entity = value;
<#					if (association.OtherSide != null || association.ManagesKeys) {#>
					if ((value != null)) 
                    {
<#						if (association.OtherSide != null) {#>
						value.<#=association.OtherSide.Member#><#if (!association.OtherSide.IsMany) {#> = this<#} else {#>.Add(this)<#}#>;
<#						}
						if (association.ManagesKeys) {
							for(int keyIdx=0;keyIdx<association.ThisKey.Count();keyIdx++) {#>
						this.<#=association.ThisKey[keyIdx].Storage#> = value.<#=association.OtherKey[keyIdx].Member#>;
<#							}#>
					}
					else 
                    {
<#							for(int keyIdx=0;keyIdx<association.ThisKey.Count();keyIdx++) {
#>						this.<#=association.ThisKey[keyIdx].Storage#> = default;
<#							}
						}
#>					}
<#					}#>
					this.SendPropertyChanged("<#=association.Member#>");
				}
			}
		}

<#				} else {#>
		<#=code.Format(association.MemberAttributes)#>EntitySet<<#=association.Type.Name#>> <#=association.Member#>
		{
			get 
            {
<#					if (needsSerializationFlag && serialization) {#>
				if (serializing && !<#=association.Storage#>.HasLoadedOrAssignedValues) 
                {
					return null;
				}
<#					} #>
				return <#=association.Storage#>;
			}
			set 
            {
				<#=association.Storage#>.Assign(value);
			}
		}

		private void attach_<#=association.Member#>(<#=association.Type.Name#> entity)
		{
			SendPropertyChanging();
			entity.<#=association.OtherSide.Member#> = this;
		}
		
		private void detach_<#=association.Member#>(<#=association.Type.Name#> entity)
		{
			SendPropertyChanging();
			entity.<#=association.OtherSide.Member#> = null;
		}
		
<#				}
			}#>
		#endregion
<#		} 
		if (data.Serialization) {#>
		
		#region Serialization
<#			if (needsSerializationFlag) {#>
		private bool serializing;
		
		[OnSerializing()]
		[EditorBrowsableAttribute(EditorBrowsableState.Never)]
		public void OnSerializing(StreamingContext context)
		{
			serializing = true;
		}
		
		[OnSerialized()]
		[EditorBrowsableAttribute(EditorBrowsableState.Never)]
		public void OnSerialized(StreamingContext context)
		{
			serializing = false;
		}
		
<#			}#>
		[OnDeserializing()]
		[EditorBrowsableAttribute(EditorBrowsableState.Never)]
		public <#if (class1 != table.BaseClass) {#>new<#}#> void OnDeserializing(StreamingContext context)
		{
			Initialize();
		}
		#endregion
<#		}
#>	}
<#		
// don't show namespaces, one is enough
if (ADD_TABLE_NAMESPACE && !String.IsNullOrEmpty(data.EntityNamespace)) {#>
}  end namespace
<#		}
		manager.EndBlock();
	}
}

#>
    #endregion // end table creation

<#

// ======================================================
// End Table generation
// ======================================================

if (data.FunctionClasses.Count > 0) 
{ #>
    <#
	foreach(var class1 in data.FunctionClasses.Where(fc => !IgnoreTable(fc.Name))) 
    {
		manager.StartNewFile(Path.ChangeExtension(class1.Name,".generated.cs"));
		if(!String.IsNullOrEmpty(data.EntityNamespace)){#>
<#		}
		if (data.Serialization) {
#>	
    [DataContract(<#=dataContractAttributes#>)]
<#		} #>
   
	<#=code.Format(class1.TypeAttributes)#>partial class <#=class1.Name#>
	{<#		
        int dataMemberIndex = 1;

        foreach(var column in class1.Columns) {#>  
        private <#=CleanMemberType(code.Format(column.Type))#> <#=column.Storage#>;
        <#} // end foreach
        
#>      
        <#=code.Format(class1.TypeAttributes)#><#=class1.Name#>()
        {
        }
		<#foreach(var column in class1.Columns) {#>      
        [global::System.Data.Linq.Mapping.ColumnAttribute(Storage="<#=column.Storage#>"<#
				if (column.Name != column.Member) {#>, Name="<#=column.Name#>"<#}
				if (!String.IsNullOrEmpty(column.DbType)) {#>, DbType="<#=column.DbType#>"<#}
                if (!column.CanBeNull && !column.IsPrimaryKey) {#>, CanBeNull=false<#} else {#>, CanBeNull=true<# }
		#>)]
<#			if (data.Serialization && ((column.MemberAttributes & MemberAttributes.AccessMask) == MemberAttributes.Public)) {
#>		[DataMember(Order=<#=dataMemberIndex++#>)]
<#			}
#>		<#=code.Format(column.MemberAttributes)#><#=CleanMemberType(code.Format(column.Type))#> <#=column.Member#>
        {
			get 
            { 
                return this.<#=column.Storage#>; 
            }
			set 
            {
				if ((this.<#=column.Storage#> != value)) 
                {
					this.<#=column.Storage#> = value;
				}
			}
		}
<#		} #>
	}
<#		
    if (!String.IsNullOrEmpty(data.EntityNamespace)) {

		}
		manager.EndBlock();
	} // end foreach
} // endif

if (!String.IsNullOrEmpty(data.ContextNamespace)) {
#>}
<#}
manager.StartFooter();#>
#pragma warning restore 1591<#
manager.EndBlock(); 
manager.Process(options.FilePerEntity);#>

<#+

    // some tables we need in the DB but not in the Service_Productive (e.g. all the "Aspnet_"-tables)
    private static bool IgnoreTable(string tableName)
    {
        // ignore all aspnet membership tables
		var isAspNetTable = tableName.ToLower().Contains("aspnet_");
		var isStoredProcedure = tableName.ToLower().Contains("sp_");
        return isAspNetTable || isStoredProcedure;
    }

    // returns the correct table interface based on the Id of the table (check DbEntity.cs for available interfaces) 
    private static string GetTableIdInterface(Class class1)
    {
        // try to find a primary key 'Id' property of type int or guid
        foreach (var column in class1.Columns.Where(c => c.IsPrimaryKey && c.Member == "Id"))
        {
            if (column.Type == typeof(int))
            {
                return $"IDbEntityId<{class1.Name}>, ";
            }
            else if (column.Type == typeof(Guid))
            {
                return "IDbEntityGuidId, ";
            }
        }

        // table doesn't have a generic Id yet
        return string.Empty;
    }

    // removes some wrongly added "System." to avoid "Unexpected use of an aliased name" errors
    public static string CleanMemberType(string input)
    {
        var output = input;

        output = output.Replace("System.global::", "global::");

        output = output.Replace("int?", "System.Nullable<int>");

        output = output.Replace("DateTime?", "System.Nullable<DateTime>");
        output = output.Replace("DateTime", "System.DateTime");

        output = output.Replace("bool?", "System.Nullable<bool>");

        output = output.Replace("Guid?", "System.Nullable<Guid>");
        output = output.Replace("Guid", "System.Guid");

        output = output.Replace("byte?", "System.Nullable<byte>");

        output = output.Replace("Binary", "System.Data.Linq.Binary");

        output = output.Replace("decimal?", "System.Nullable<decimal>");

        return output;
    }


    private static string GetInterfaces(List<Column> columns, string className)
    {
        var interfaces = new List<string>();

        foreach (var column in columns)
        {
            switch (column.Member)
            {
                case "DeleteDbEntity": interfaces.Add("IDbDeleteDbEntity"); break;
                case "InsertDateTime": interfaces.Add("IDbInsertDateTime"); break;
                case "InsertUserId":
                    /* 
                     * TableLog uses the InsertUserId but it's nullable and can thus not implement the interface.
                     * We should consider making either InsertUserId interface nullable or change the property in the TableLog.
                    */ 
  

                    // todo: check type and only create interface if types match
                    if (className != "TableLog")
                    {
                        interfaces.Add("IDbInsertUserId"); 
                    }
                    break;
                case "UpdateDateTime": interfaces.Add("IDbUpdateDateTime"); break;
                case "UpdateUserId": interfaces.Add("IDbUpdateUserId"); break;
                case "Year": interfaces.Add("IYear"); break;
                case "VerifiedDateTime": interfaces.Add("IVerifiedDateTime"); break;
            }
        }

        var leadingComma = interfaces.Any() ? ", " : string.Empty;

        return leadingComma + string.Join(", ", interfaces);
    }

    public static string AddFullNamespace(string input)
    {
        var output = input;

        output = input.Replace("MappingSource", "System.Data.Linq.Mapping.MappingSource");

        return output;
    }
    #>